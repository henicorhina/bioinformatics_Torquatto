# Calculate the percentage of G nucleotides
G_percent <- (G_count / total_count) * 100
# Print the percentage of G nucleotides
print(G_percent)
# Load the seqinr package
library(seqinr)
# Convert the alignment to the seqinr format
seqinr_alignment <- msaConvert(clustalw_alignment, type = "seqinr")
# Compute a distance matrix from the converted alignment
distance_matrix <- dist.alignment(seqinr_alignment)
# Print the distance matrix
print(distance_matrix)
# Find the indices of the maximum and minimum distances in the distance matrix
max_distance_index <- which(distance_matrix == max(distance_matrix), arr.ind = TRUE)
min_distance_index <- which(distance_matrix == min(distance_matrix), arr.ind = TRUE)
# Get the sample names corresponding to the maximum and minimum distances
samples <- colnames(seqinr_alignment)
most_distant_samples <- samples[max_distance_index]
closest_samples <- samples[min_distance_index]
# Print the results
print("Most distantly related samples:")
print(most_distant_samples)
print("Two most closely related samples:")
print(closest_samples)
# Find the maximum and minimum distances in the distance matrix
max_distance <- max(distance_matrix)
min_distance <- min(distance_matrix)
# Find the indices of the maximum and minimum distances
max_distance_indices <- which(distance_matrix == max_distance, arr.ind = TRUE)
min_distance_indices <- which(distance_matrix == min_distance, arr.ind = TRUE)
# Get the sample names corresponding to the maximum and minimum distances
samples <- colnames(seqinr_alignment)
most_distant_samples <- samples[max_distance_indices[1, ]]
closest_samples <- samples[min_distance_indices[1, ]]
# Print the results
print("Most distantly related samples:")
print(most_distant_samples)
print("Two most closely related samples:")
print(closest_samples)
# Find the maximum and minimum distances in the distance matrix
max_distance <- max(distance_matrix)
min_distance <- min(distance_matrix)
# Find the indices of the maximum and minimum distances
max_distance_indices <- which(distance_matrix == max_distance, arr.ind = TRUE)
min_distance_indices <- which(distance_matrix == min_distance, arr.ind = TRUE)
# Get the sample names corresponding to the maximum and minimum distances
samples <- colnames(seqinr_alignment)
most_distant_samples <- c(rownames(distance_matrix)[max_distance_indices[, 1]], colnames(distance_matrix)[max_distance_indices[, 2]])
closest_samples <- c(rownames(distance_matrix)[min_distance_indices[, 1]], colnames(distance_matrix)[min_distance_indices[, 2]])
# Print the results
print("Most distantly related samples:")
print(most_distant_samples)
print("Two most closely related samples:")
print(closest_samples)
# Initialize variables to store the maximum and minimum distances and their corresponding sample pairs
max_distance <- 0
min_distance <- Inf
max_pair <- NULL
min_pair <- NULL
# Loop through the distance matrix to find the maximum and minimum distances
for (i in 1:(nrow(distance_matrix) - 1)) {
for (j in (i + 1):ncol(distance_matrix)) {
# Update maximum distance and corresponding sample pair
if (distance_matrix[i, j] > max_distance) {
max_distance <- distance_matrix[i, j]
max_pair <- c(row.names(distance_matrix)[i], colnames(distance_matrix)[j])
}
# Update minimum distance and corresponding sample pair
if (distance_matrix[i, j] < min_distance) {
min_distance <- distance_matrix[i, j]
min_pair <- c(row.names(distance_matrix)[i], colnames(distance_matrix)[j])
}
}
}
# Find the minimum distance in the distance matrix
min_distance <- min(distance_matrix)
# Find the row and column indices of the minimum distance
min_distance_index <- which(distance_matrix == min_distance, arr.ind = TRUE)
# Get the names of the sequences corresponding to the minimum distance
closest_samples <- rownames(distance_matrix)[min_distance_index[1]]
# Print the result
print("Two most closely related samples:")
print(closest_samples)
print(min_distance_index)
print(ls())
# Apply the column mask to your alignment
myMaskedAlignment <- clustalw_alignment
colM <- IRanges(start = 1, end = 100)  # Define the column mask
colmask(myMaskedAlignment) <- colM  # Apply the column mask to the alignment
# View the masked alignment
print(myMaskedAlignment)
# Compute the distance matrix from the masked alignment
distance_matrix <- dist.alignment(myMaskedAlignment)
# Print the distance matrix
print(distance_matrix)
# Convert the alignment to the appropriate class
aligned_sequences <- msaConvert(myMaskedAlignment, type = "alignment")
# Compute the distance matrix from the converted alignment
distance_matrix <- dist.alignment(aligned_sequences)
# Convert the alignment to the appropriate class
aligned_sequences <- msaConvert(myMaskedAlignment, type = "alignment")
# Compute the distance matrix directly from the alignment object
distance_matrix <- dist.alignment(myMaskedAlignment)
# Convert the MsaDNAMultipleAlignment object to an alignment object
aligned_sequences <- msaConvert(myMaskedAlignment, type = "DNAMultipleAlignment")
# Convert the MsaDNAMultipleAlignment object to an alignment object
aligned_sequences <- msaConvert(myMaskedAlignment, type = "ape::DNAbin")
install.packages("seqinr")
install.packages("seqinr")
library(seqinr)
library(seqinr)
# Convert the MsaDNAMultipleAlignment object to seqinr format
seqinr_alignment <- as.alignment(myMaskedAlignment)
# Load the seqinr package
library(seqinr)
# Get the sequences from the MsaDNAMultipleAlignment object
sequences <- unlist(as.list(myMaskedAlignment))
# Unmask the alignment
unmasked_alignment <- unmask(myMaskedAlignment)
# Print the unmasked alignment
print(unmasked_alignment)
print(myMaskedAlignment)
# Compute the distance matrix from the alignment
distance_matrix <- dist.alignment(myMaskedAlignment)
# Convert the MsaDNAMultipleAlignment object to an alignment object
aligned_sequences <- msaConvert(myMaskedAlignment, type = "seqinr::alignment")
# Compute the distance matrix from the converted alignment object
distance_matrix <- dist.alignment(aligned_sequences)
# Find the indices of the pair with the smallest distance
min_distance_index <- which(distance_matrix == min(distance_matrix), arr.ind = TRUE)
# Get the names of the sequences corresponding to the indices
closest_samples <- rownames(myMaskedAlignment)[min_distance_index[, 1]]
# Get the names of the sequences corresponding to the indices
closest_samples <- rownames(myMaskedAlignment)[min_distance_index[, 1]]
# Print the names of the two closest samples
print(closest_samples)
# Compute the distance matrix from the masked alignment
distance_matrix <- dist.alignment(myMaskedAlignment)
# Print the distance matrix
print(distance_matrix)
# Print the names of the two closest samples
print(closest_samples)
letter_freq
class(letter_freq)
letter_freq[1,1]
letter_freq[,3]
letter_freq[,"G"]
GC_content <- (letter_freq[,"G"] + letter_freq[,"C"]) / sum(letter_freq) * 100
GC_content
sum(letter_freq[,1:4]
)
GC_content <- (letter_freq[,"G"] + letter_freq[,"C"]) / sum(letter_freq[,1:4]) * 100
GC_content
(letter_freq[,"G"] + letter_freq[,"C"])
library(dplyr)
library(tidyr)
library(phangorn)
library(seqinr)
library(Biostrings)
# load in all of the libraries that you might need
# this should always be at the start of your script
library(msa)
install.packages("phangorn")
install.packages("tidyr")
install.packages("dplyr")
library(msa)
library(Biostrings)
library(seqinr)
library(phangorn)
library(tidyr)
library(dplyr)
install.packages("phangorn") - the latest development version remotes::install_github("KlausVigo/phangorn")
install.packages("phangorn")
install.packages("phangorn")
library(phangorn)
library(tidyr)
library(dplyr)
albatrossAln <- msa(seqs)
seq_1 <- readDNAStringSet("sequence-1fb")
seq_2 <- readDNAStringSet("sequence-2fb")
seq_3 <- readDNAStringSet("sequence-3fb")
seq_4 <- readDNAStringSet("sequence-4fb")
seq_5 <- readDNAStringSet("sequence-5fb")
seqs <- c(seq_1, seq_2, seq_3, seq_4, seq_5)
albatrossAln <- msa(seqs)
nchar(albatrossAln)
print(albatrossAln, show="complete")
alFreq <- alphabetFrequency(albatrossAln)
alFreq
GC <- sum(alFreq[,"C"]) + sum(alFreq[,"G"])
AT <- sum(alFreq[,"A"]) + sum(alFreq[,"T"])
GC / (GC + AT )
albatrossAln2 <- msaConvert(albatrossAln, type="seqinr::alignment")
d <- dist.alignment(albatrossAln2, "identity")
help(dist.alignment)
help(??dist.alignment)
seq_1_AA <- Biostrings::translate(seq_1)
print(seq_1_AA)
# calculate the identity matrix
# first, convert the alignment to the seqinr format using msaConvert
# because the dist.alignment() function is part of the seqinr package
albatrossAln2 <- msaConvert(albatrossAln, type="seqinr::alignment")
d <- dist.alignment(albatrossAln2, "identity")
# calculate the identity matrix
# first, convert the alignment to the seqinr format using msaConvert
# because the dist.alignment() function is part of the seqinr package
sequence-1fb <- msaConvert(sequence-1fb, type="seqinr::alignment")
# calculate the identity matrix
# first, convert the alignment to the seqinr format using msaConvert
# because the dist.alignment() function is part of the seqinr package
seq_1 <- msaConvert(sequence-1fb, type="seqinr::alignment")
bulldog <- msa(seqs)
# combine samples into a single variable using the combine ('c') function
seqs <- c(seq_1, seq_2, seq_3, seq_4, seq_5)
bulldog <- msa(seqs)
# check the alignment length, two different ways
nchar(bulldog)
print(bulldog, show="complete")
alFreq <- alphabetFrequency(bulldog)
alFreq
GC <- sum(alFreq[,"C"]) + sum(alFreq[,"G"])
AT <- sum(alFreq[,"A"]) + sum(alFreq[,"T"])
GC / (GC + AT )
# calculate the identity matrix
# first, convert the alignment to the seqinr format using msaConvert
# because the dist.alignment() function is part of the seqinr package
seq_1 <- msaConvert(bulldog, type="seqinr::alignment")
d <- dist.alignment(bulldog, "identity")
library(msa)
d <- dist.alignment(bulldog, "identity")
seq_1_AA <- Biostrings::translate(seq_1)
library(Biostrings)
# Replace 'sequence.fasta' with the path to your file
dna_seq <- readDNAStringSet("sequence-1fb")
# Translate the nucleotide sequence
translated_seq <- translate(dna_seq[[1]])  # Assuming there's only one sequence in the file
print(translated_seq)
# Translate the nucleotide sequence
translated_seq <- translate(dna_seq[[1]])  # Assuming there's only one sequence in the file
modified_seq <- dna_seq[[1]]
modified_seq[15516] <- "A"
# Translate the nucleotide sequence
translated_seq <- translate(dna_seq[[1]])  # Assuming there's only one sequence in the file
modified_seq <- dna_seq[[1]]
modified_seq[15516] <- "A"
# Translate the nucleotide sequence
translated_seq <- translate(dna_seq[[1]])  # Assuming there's only one sequence in the file
translated_seq <- translate(modified_seq)
modified_seq <- dna_seq[[1]]
modified_seq <- paste0(substr(modified_seq, 1, 15516), substr(modified_seq, 15518, nchar(modified_seq)))
translated_seq <- translate(modified_seq)
dna_string <- DNAString(modified_seq)
translated_seq <- translate(dna_string)
substring <- substr(dna_string, start = 1, stop = 15516)
translated_seq <- translate(Biostrings::DNAString(substring))
substring <- substr(dna_string, start = 1, stop = 15515)
translated_seq <- translate(Biostrings::DNAString(substring))
print(translated_seq)
install.packages("UniprotR")
install.packages("protti")
install.packages("protti")
library(UniprotR)
install.packages("UniprotR")
library(UniprotR)
install.packages("GenomicAlignments")
library(UniprotR)
BiocManager::install("GenomicAlignments")
install.packages("UniprotR")
install.packages("protti")
library(UniprotR)
library(protti)
install.packages("remotes")
remotes::install_github("jnsebgosselin/r3dmol")
library(UniprotR)
library(protti)
# Print the translated amino acid sequence
print(translated_seq)
# write the alignment to a fasta file (harder than I expected to figure this out)
# there is a write function in the phangorn package, but not one that I could find in seqinr or Biostrings
# Biostrings has a write function, but not for fasta-formatted files
sequence1fb_phyDat <- msaConvert(sequence-1fb, type="phangorn::phyDat")
# write the alignment to a fasta file (harder than I expected to figure this out)
# there is a write function in the phangorn package, but not one that I could find in seqinr or Biostrings
# Biostrings has a write function, but not for fasta-formatted files
sequencefb_phyDat <- msaConvert(sequence-1fb, type="phangorn::phyDat")
library(Biostrings)
# Define the file name for the FASTA file
fasta_file <- "translated_sequences.fasta"
# Write the AAStringSet object to a FASTA file
writeXStringSet(translated_seq, file = fasta_file)
library(Biostrings)
# Convert AAStringSet to XStringSet
xstring_set <- AAStringSet2XStringSet(translated_seq)
library(Biostrings)
# Define the file name for the FASTA file
fasta_file <- "translated_sequences.fasta"
# Write the AAString or AAStringSet object to a FASTA file
writeXStringSet(translated_seq, file = fasta_file)
library(Biostrings)
# Convert AAStringSet to character vector
aa_seqs <- as.character(translated_seq)
# Convert character vector to XStringSet
xstring_set <- DNAStringSet(aa_seqs)
library(seqinr)
# Convert AAStringSet to character vector
aa_seqs <- as.character(translated_seq)
library(seqinr)
# Convert AAStringSet to character vector
aa_seqs <- as.character(translated_seq)
# Define the file name for the FASTA file
fasta_file <- "translated_sequences.fasta"
# Write amino acid sequences to a FASTA file
write.fasta(sequences = aa_seqs, names = paste0("Sequence_", seq_along(aa_seqs)), file.out = fasta_file)
# Read the FASTA file back into R
fasta_data <- read.fasta(fasta_file)
# Access sequences and names
sequences <- fasta_data$seq
names <- fasta_data$name
# Print the first sequence
print(sequences[[1]])
# Print the name of the first sequence
print(names[1])
# Access sequences and names
sequences <- fasta_data$seq
names <- fasta_data$name
# Print the first sequence
print(sequences[[1]])
# Print the name of the first sequence
print(names[1])
# Write amino acid sequences to a FASTA file
write.fasta(sequences = aa_seqs, names = paste0("Sequence_", seq_along(aa_seqs)), file.out = fasta_file)
# Read the FASTA file back into R
fasta_data <- read.fasta(fasta_file)
# Convert AAStringSet to character vector
aa_seqs <- as.character(translated_seq)
aa_seqs
#Creating FASTA File from aa seq ####
output_file <- "aa_sequence.fasta"
writeXStrings(aa_seqs, file = output_file,
format = "fasta", width = 60)
writeXStringsSet(aa_seqs, file = output_file,
format = "fasta", width = 60)
library(Biostrings)
#Creating FASTA File from aa seq ####
output_file <- "aa_sequence.fasta"
writeXStringsSet(aa_seqs, file = output_file,
format = "fasta", width = 60)
?write.fasta
aa_seqs
write.fasta(aa_seqs, "french_bulldog_aa", output_file)
getwd()
setwd(../)
setwd("../")
getwd()
setwd("../")
getwd()
setwd("../")
getwd()
setwd("../")
getwd()
getwd("kylecameron/")
getwd()
setwd("kylecameron/")
getwd()
setwd("Documents/GitHub/bioinformatics/")
getwd()
write.fasta(aa_seqs, "french_bulldog_aa", output_file)
#Creating FASTA File from aa seq ####
output_file <- "aa_sequence.fasta"
writeXStringsSet(aa_seqs, file = output_file,
format = "fasta", width = 60)
write.fasta(aa_seqs, "french_bulldog_aa", output_file)
#5. Read acession numbers into R ####
acession_numbers <- c("acession numbers here")
data <- read.csv("homework6fastafiles")
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
accession_string <- paste(accession_numbers, collapse = ", ")
print(accession_string)
install.packages("biomaRt")
library(biomaRt)
library(biomaRt)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("biomaRt")
library(biomaRt)
get_GO_terms <- function(accession_number) {
mart <- useMart("unimart")
dataset <- useDataset("unimart", "uniprot")
go_info <- GetProteinGOInfo(accession_number, mart = mart, dataset = dataset)
go_terms <- go_info$go_id
return(go_terms)
}
# Example list of accession numbers
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
# Initialize a list to store GO terms for each accession number
all_go_terms <- list()
for (accession in accession_numbers) {
go_terms <- get_GO_terms(accession)
all_go_terms[[accession]] <- go_terms
}
# Example list of accession numbers
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
# Initialize a list to store GO terms for each accession number
all_go_terms <- list()
for (accession in accession_numbers) {
go_terms <- get_GO_terms(accession)
all_go_terms[[accession]] <- go_terms
}
# Load necessary library
library(biomaRt)
# Check available BioMart databases
listMarts()
dataset <- useDataset("unimart", mart=mart)
get_GO_terms <- function(accession_number) {
mart <- useMart("ensembl")
dataset <- useDataset("unimart", mart=mart)
go_info <- GetProteinGOInfo(accession_number, mart = mart, dataset = dataset)
go_terms <- go_info$go_id
return(go_terms)
}
# Example list of accession numbers
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
# Initialize a list to store GO terms for each accession number
all_go_terms <- list()
for (accession in accession_numbers) {
go_terms <- get_GO_terms(accession)
all_go_terms[[accession]] <- go_terms
}
# Load necessary library
library(biomaRt)
# Check available BioMart databases
listMarts()
get_GO_terms <- function(accession_number) {
mart <- useMart("ensembl")
listDatasets(mart)
dataset <- useDataset("unimart", mart=mart)
go_info <- GetProteinGOInfo(accession_number, mart = mart, dataset = dataset)
go_terms <- go_info$go_id
return(go_terms)
}
# Example list of accession numbers
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
# Initialize a list to store GO terms for each accession number
all_go_terms <- list()
for (accession in accession_numbers) {
go_terms <- get_GO_terms(accession)
all_go_terms[[accession]] <- go_terms
}
}?
?
library(UniprotR)
library(UniprotR)
library(protti)
data <- read.csv("5assenfb.txt")
data <- read.table("5assenf.txt", header = TRUE)  # Change header to FALSE if your file doesn't have a header
data <- read.table("5assenfb.txt", header = TRUE)  # Change header to FALSE if your file doesn't have a header
data <- read.table("5assenfb.txt", header = FALSE)  # Change header to FALSE if your file doesn't have a header
# Read the content of the file into a character vector
file_content <- readLines("5assenfb.txt")
# Replace spaces with tabs to convert to tab-separated format
tab_separated_content <- gsub(" +", "\t", file_content)
# Write the modified content to a new file
writeLines(tab_separated_content, "5assenfb_tab_separated.txt")
data <- read.table("5assenfb.txt", header = FALSE)  # Change header to FALSE if your file doesn't have a header
data <- read.table("5assenfb.txt", header = TRUE)  # Change header to FALSE if your file doesn't have a header
data <- read.table("5assenfb.txt", header = TRUE, sep = "\t")  # Assuming tab-separated file
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
accession_string <- paste(accession_numbers, collapse = ", ")
print(accession_string)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("biomaRt")
t
library(biomaRt)
get_GO_terms <- function(accession_number) {
mart <- useMart("unimart")
dataset <- useDataset("unimart", "uniprot")
# Load necessary library
library(biomaRt)
# Check available BioMart databases
listMarts()
get_GO_terms <- function(accession_number) {
mart <- useMart("ensembl")
listDatasets(mart)
dataset <- useDataset("unimart", mart=mart)
go_info <- GetProteinGOInfo(accession_number, mart = mart, dataset = dataset)
go_terms <- go_info$go_id
return(go_terms)
}
# Example list of accession numbers
accession_numbers <- c("Q1HK80", "Q9ZZ57", "Q08GU4", "A0A8U0SPQ4", "F4YPU8")
# Initialize a list to store GO terms for each accession number
all_go_terms <- list()
for (accession in accession_numbers) {
go_terms <- get_GO_terms(accession)
all_go_terms[[accession]] <- go_terms
}
# View the retrieved GO terms
print(all_go_terms)
install.packages("ggplot2")
library(ggplot2)
PlotGoInfo(all_go_terms)
View(get_GO_terms)
library(ggplot2)
plot <- ggplot(data = your_data) + geom_bar(aes(x = your_x_variable, y = your_y_variable), stat = "identity")
plot
ggsave("plot.png", plot)
getwd()
list.files()
getwd()
getwd()
getwd()
